/* Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
	"fmt"
	"reflect"
	"sort"
	"strings"
	"sync"

	"github.com/golang/glog"
	"github.com/neoul/gnxi/gnmi/model/gostruct"
	"github.com/neoul/gnxi/utilities/xpath"
	"github.com/neoul/libydb/go/ydb"
	"github.com/neoul/trie"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	gnmipb "github.com/openconfig/gnmi/proto/gnmi"
)

// Model contains the model data and GoStruct information for a device.
type Model struct {
	*MO
	schema    func() (*ytypes.Schema, error)
	modelData []*gnmipb.ModelData
	ChangeNotification
	StateConfig
	StateSync
	sync.RWMutex
	// block        *ydb.YDB
	syncRequired *trie.Trie
	transaction  *setTransaction
	updatedroot  *MO // a fake data tree to represent the changed data.
}

// NewModel returns a new Model instance based on model/gostruct.
//  - ChangeNotification: A callback interface invoked when the data in the Model is changed
//  - StateConfig: The callback interface of the data source invoked when a gNMI Set RPC is issued
//  - StateSync: The callback interface of the data source invoked when a gNMI Get RPC is issued for data update.
func NewModel(cn ChangeNotification, sc StateConfig, ss StateSync) (*Model, error) {
	return NewCustomModel(gostruct.Schema, gostruct.Î“ModelData, cn, sc, ss)
}

// NewCustomModel returns new user-defined Model instance.
//  - schema func: Schema() func generated by ygot
//  - modelData: Supported models generated by ygot
//  - ChangeNotification: A callback interface invoked when the data in the Model is changed
//  - StateConfig: The callback interface of the data source invoked when a gNMI Set RPC is issued
//  - StateSync: The callback interface of the data source invoked when a gNMI Get RPC is issued for data update.
func NewCustomModel(schema func() (*ytypes.Schema, error), modelData []*gnmipb.ModelData,
	cn ChangeNotification, sc StateConfig, ss StateSync) (*Model, error) {
	s, err := schema()
	if err != nil {
		return nil, status.Error(codes.Internal, err.Error())
	}
	m := &Model{
		MO:                 (*MO)(s),
		schema:             schema,
		modelData:          modelData,
		StateConfig:        sc,
		StateSync:          ss,
		ChangeNotification: cn,
	}
	if m.StateConfig == nil {
		m.StateConfig = &emptySource{}
	}
	m.syncRequired = trie.New()
	for _, p := range srpaths {
		// glog.Infof("sync-required-path %s", p)
		entry := m.FindSchemaByXPath(p)
		if entry == nil {
			continue
		}
		sentries := []*yang.Entry{}
		for entry != nil {
			sentries = append([]*yang.Entry{entry}, sentries...)
			entry = entry.Parent
		}
		m.syncRequired.Add(p, sentries)
	}
	return m, nil
}

// Load loads the startup state of the Model.
//  - startup: The YAML or JSON startup data to populate the creating structure (gostruct).
func (m *Model) Load(startup []byte) error {
	mo, err := m.NewRoot(startup)
	if err != nil {
		return err
	}
	m.MO = mo

	// m.block, _ = ydb.OpenWithSync("gnmi.target", m)
	// if !*disableYdbChannel {
	// 	err := m.block.Connect("uss://gnmi", "pub")
	// 	if err != nil {
	// 		m.block.Close()
	// 		return err
	// 	}
	// 	m.block.Serve()
	// }
	return nil
}

// SupportedModels returns a list of supported models.
func (m *Model) SupportedModels() []string {
	mDesc := make([]string, len(m.modelData))
	for i, m := range m.modelData {
		mDesc[i] = fmt.Sprintf("%s %s", m.Name, m.Version)
	}
	sort.Strings(mDesc)
	return mDesc
}

// CheckModels checks whether models are supported by the model. Return error if anything is unsupported.
func (m *Model) CheckModels(models []*gnmipb.ModelData) error {
	for _, mo := range models {
		isSupported := false
		for _, supportedModel := range m.modelData {
			if reflect.DeepEqual(mo, supportedModel) {
				isSupported = true
				break
			}
		}
		if !isSupported {
			return fmt.Errorf("unsupported model: %v", m)
		}
	}
	return nil
}

// GetModelData - returns ModelData of the model.
func (m *Model) GetModelData() []*gnmipb.ModelData {
	return m.modelData
}

// FindAllPaths - finds all XPaths against to the gNMI Path that has wildcard
func (m *Model) FindAllPaths(path *gnmipb.Path) ([]string, bool) {
	elems := path.GetElem()
	if len(elems) <= 0 {
		return []string{"/"}, true
	}
	p := ""
	sp := pathFinder{
		t:    m.GetRootType(),
		path: &p,
	}

	rsplist := m.findAllPaths(sp, elems)
	num := len(rsplist)
	if num <= 0 {
		return []string{}, false
	}
	rlist := make([]string, num)
	for i := 0; i < num; i++ {
		rlist[i] = *rsplist[i].path
	}
	return rlist, true
}

// findAllPaths - finds all XPaths matched to the gNMI Path.
// It is used to find all schema nodes matched to a wildcard path.
func (m *Model) findAllPaths(sp pathFinder, elems []*gnmipb.PathElem) []pathFinder {
	// select all child nodes if the current node is a list.
	if sp.t.Kind() == reflect.Map {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}
	if len(elems) <= 0 {
		return []pathFinder{sp}
	}
	if ydb.IsTypeScalar(sp.t) {
		return []pathFinder{}
	}
	elem := elems[0]
	// fmt.Println("** Search", elem.GetName(), "from", sp.t)
	if elem.GetName() == "*" {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, celems)...)
			}
		}
		return rv
	} else if elem.GetName() == "..." {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				ccsplist := m.findAllPaths(csp, celems)
				if len(ccsplist) > 0 {
					rv = append(rv, ccsplist...)
				}
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}

	elemName := elem.GetName()
	csp, ok := findSchemaPath(sp, elemName)
	if !ok {
		return []pathFinder{}
	}
	keys := elem.GetKey()
	if keys != nil && len(keys) > 0 {
		if ydb.IsTypeMap(csp.t) {
			schema := m.FindSchemaByType(csp.t.Elem())
			if schema != nil {
				npath := ""
				knamelist := strings.Split(schema.Key, " ")
				for _, kname := range knamelist {
					kvalue, ok := keys[kname]
					if ok {
						npath = npath + fmt.Sprintf("[%s=%s]", kname, kvalue)
					} else {
						npath = ""
						break
					}
				}
				if npath != "" {
					npath = *csp.path + npath
					csp.path = &npath
				}
			}
		}
	}

	return m.findAllPaths(csp, elems[1:])
}

// Get - Get all values and paths (XPath, Value) from the root
func (m *Model) Get(path *gnmipb.Path) ([]*DataAndPath, bool) {
	return m.Find(m.GetRoot(), path)
}

// FindOption is an interface that is implemented for the option of Model.Find().
type FindOption interface {
	// IsFindOpt is a marker method for each FindOption.
	IsFindOpt()
}

// FindByModel is used to find data and paths with schema info.
type FindByModel struct {
	*Model
}

// IsFindOpt - FindByModel is a FindOption.
func (f *FindByModel) IsFindOpt() {}

func hasFindByModel(opts []FindOption) *Model {
	for _, o := range opts {
		switch v := o.(type) {
		case *FindByModel:
			return v.Model
		}
	}
	return nil
}

// AddFakePrefix is a FindOption to add a prefix to DataAndPath.Path.
type AddFakePrefix struct {
	Prefix *gnmipb.Path
}

// IsFindOpt - AddFakePrefix is a FindOption.
func (f *AddFakePrefix) IsFindOpt() {}

func hasAddFakePrefix(opts []FindOption) *gnmipb.Path {
	for _, o := range opts {
		switch v := o.(type) {
		case *AddFakePrefix:
			return v.Prefix
		}
	}
	return nil
}

func replaceAddFakePrefix(opts []FindOption, opt FindOption) []FindOption {
	var ok bool
	for i, o := range opts {
		_, ok := o.(*AddFakePrefix)
		if ok {
			opts[i] = opt
			ok = true
			break
		}
	}
	if !ok {
		opts = append(opts, opt)
	}
	return opts
}

// FindAndSort is used to sort the found result.
type FindAndSort struct{}

// IsFindOpt - FindAndSort is a FindOption.
func (f *FindAndSort) IsFindOpt() {}

func hasFindAndSort(opts []FindOption) bool {
	for _, o := range opts {
		switch o.(type) {
		case *FindAndSort:
			return true
		}
	}
	return false
}

// Find - Find all values and paths (XPath, Value) from the base ygot.GoStruct
func (m *Model) Find(base interface{}, path *gnmipb.Path, opts ...FindOption) ([]*DataAndPath, bool) {
	t := reflect.TypeOf(base)
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return []*DataAndPath{}, false
	}
	fprefix := hasAddFakePrefix(opts)
	if fprefix == nil {
		fprefix = xpath.EmptyGNMIPath
	}
	prefix := xpath.ToXPath(fprefix)

	elems := path.GetElem()
	if len(elems) <= 0 {
		dataAndGNMIPath := &DataAndPath{
			Value: base, Path: prefix,
		}
		return []*DataAndPath{dataAndGNMIPath}, true
	}
	for _, e := range elems {
		if e.Name == "*" || e.Name == "..." {
			break
		}
		entry = entry.Dir[e.Name]
		if entry == nil {
			return []*DataAndPath{}, false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return []*DataAndPath{}, false
				}
			}
		}
	}
	v := reflect.ValueOf(base)
	datapath := &dataAndPath{Value: v, Key: []string{""}}
	founds := findAllData(datapath, elems, opts...)
	// fmt.Println(founds)
	num := len(founds)
	if num <= 0 {
		return []*DataAndPath{}, false
	}

	rvalues := make([]*DataAndPath, 0, num)
	for _, each := range founds {
		if each.Value.CanInterface() {
			var p string
			if prefix == "/" {
				p = strings.Join(each.Key, "/")
			} else {
				p = prefix + strings.Join(each.Key, "/")
			}
			dataAndGNMIPath := &DataAndPath{
				Value: each.Value.Interface(),
				Path:  p,
			}
			rvalues = append(rvalues, dataAndGNMIPath)
		}
	}
	if hasFindAndSort(opts) {
		sort.Slice(rvalues, func(i, j int) bool {
			return rvalues[i].Path < rvalues[j].Path
		})
	}
	return rvalues, true
}

// ListAll find and list all child values.
func (m *Model) ListAll(base interface{}, path *gnmipb.Path, opts ...FindOption) []*DataAndPath {
	var targetNodes []*DataAndPath
	var children []*DataAndPath
	if path == nil {
		targetNodes, _ = m.Find(base, xpath.WildcardGNMIPathDot3, opts...)
		return targetNodes
	}

	targetNodes, _ = m.Find(base, path, opts...)
	for _, targetNode := range targetNodes {
		switch v := targetNode.Value.(type) {
		case ygot.GoStruct:
			tpath, _ := xpath.ToGNMIPath(targetNode.Path)
			opts = replaceAddFakePrefix(opts, &AddFakePrefix{Prefix: tpath})
			allNodes, _ := m.Find(v, xpath.WildcardGNMIPathDot3, opts...)
			for _, node := range allNodes {
				children = append(children, node)
			}
		default:
			children = append(children, targetNode)
		}
	}
	return children
}

// ValidatePathSchema - validates all schema of the gNMI Path.
func (m *Model) ValidatePathSchema(path *gnmipb.Path) bool {
	t := m.GetRootType()
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return false
	}

	elems := path.GetElem()
	if len(elems) <= 0 {
		return true
	}
	for _, e := range elems {
		entry = entry.Dir[e.Name]
		if entry == nil {
			return false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return false
				}
			}
		}
	}
	return true
}

// FindSchemaPaths - validates all schema of the gNMI Path.
func (m *Model) FindSchemaPaths(path *gnmipb.Path) ([]string, bool) {
	t := m.GetRootType()
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return nil, false
	}
	var elems []*gnmipb.PathElem
	elems = path.GetElem()
	if len(elems) == 0 {
		return []string{"/"}, true
	}
	paths := m.findSchemaPath("", entry, elems)
	// for i, p := range paths {
	// 	fmt.Println(i, p)
	// }
	return paths, true
}

func (m *Model) findSchemaPath(prefix string, parent *yang.Entry, elems []*gnmipb.PathElem) []string {
	if len(elems) == 0 {
		return []string{prefix}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]string, 0, 8)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]string, 0, 16)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[1:])...)
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[0:])...)
		}
		return founds
	}
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
	}
	return m.findSchemaPath(prefix+"/"+e.Name, entry, elems[1:])
}

func (m *Model) findDataPath(prefix string, parent *yang.Entry, elems []*gnmipb.PathElem) []string {
	if len(elems) == 0 {
		return []string{prefix}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]string, 0, 8)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]string, 0, 16)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[1:])...)
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[0:])...)
		}
		return founds
	}
	name := e.Name
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
		knames := strings.Split(entry.Key, " ")
		for _, kname := range knames {
			if kval, ok := e.Key[kname]; ok {
				if kval == "*" {
					break
				}
				name = fmt.Sprintf("%s[%s=%s]", name, kname, kval)
			} else {
				break
			}
		}
	}
	return m.findDataPath(prefix+"/"+name, entry, elems[1:])
}

type dataAndSchemaPath struct {
	schemaPath *string
	dataPath   *string
}

func (m *Model) findSchemaAndDataPath(path dataAndSchemaPath, parent *yang.Entry, elems []*gnmipb.PathElem) []dataAndSchemaPath {
	if len(elems) == 0 {
		return []dataAndSchemaPath{path}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]dataAndSchemaPath, 0, 8)
		for cname, centry := range parent.Dir {
			datapath := *path.dataPath + "/" + cname
			schemapath := *path.schemaPath + "/" + cname
			path.dataPath = &datapath
			path.schemaPath = &schemapath
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]dataAndSchemaPath, 0, 16)
		for cname, centry := range parent.Dir {
			datapath := *path.dataPath + "/" + cname
			schemapath := *path.schemaPath + "/" + cname
			path.dataPath = &datapath
			path.schemaPath = &schemapath
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[1:])...)
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[0:])...)
		}
		return founds
	}
	name := e.Name
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
		knames := strings.Split(entry.Key, " ")
		for _, kname := range knames {
			if kval, ok := e.Key[kname]; ok {
				if kval == "*" {
					break
				}
				name = fmt.Sprintf("%s[%s=%s]", name, kname, kval)
			} else {
				break
			}
		}
	}
	datapath := *path.dataPath + "/" + name
	schemapath := *path.schemaPath + "/" + e.Name
	path.dataPath = &datapath
	path.schemaPath = &schemapath
	return m.findSchemaAndDataPath(path, entry, elems[1:])
}

// UpdateCreate is a function of StateUpdate Interface to add a new value to the path of the Model.
func (m *Model) UpdateCreate(path string, value string) error {
	// fmt.Printf("m.UpdateCreate %v %v {\n", path, value)
	schema := m.RootSchema()
	err := ValWrite(schema, m.GetRoot(), path, value)
	if err == nil {
		fakeRoot := m.updatedroot.GetRoot()
		ValWrite(schema, fakeRoot, path, value)
		if m.ChangeNotification != nil {
			m.ChangeNotification.ChangeCreated(path, fakeRoot)
		}
	} else {
		glog.Errorf("%v", err)
	}
	// fmt.Println("}")
	return err
}

// UpdateReplace is a function of StateUpdate Interface to replace the value in the path of the Model.
func (m *Model) UpdateReplace(path string, value string) error {
	// fmt.Printf("m.UpdateCreate %v %v {\n", path, value)
	schema := m.RootSchema()
	err := ValWrite(schema, m.GetRoot(), path, value)
	if err == nil {
		fakeRoot := m.updatedroot.GetRoot()
		ValWrite(schema, fakeRoot, path, value)
		if m.ChangeNotification != nil {
			m.ChangeNotification.ChangeReplaced(path, fakeRoot)
		}
	} else {
		glog.Errorf("%v", err)
	}
	// fmt.Println("}")
	return err
}

// UpdateDelete is a function of StateUpdate Interface to delete the value in the path of the Model.
func (m *Model) UpdateDelete(path string) error {
	// fmt.Printf("m.UpdateDelete %v {\n", path)
	schema := m.RootSchema()
	err := ValDelete(schema, m.GetRoot(), path)
	if err == nil {
		if m.ChangeNotification != nil {
			m.ChangeNotification.ChangeDeleted(path)
		}
	} else {
		glog.Errorf("%v", err)
	}
	// fmt.Println("}")
	return err
}

// UpdateStart indicates the start of the Model instance update
func (m *Model) UpdateStart() {
	m.Lock()
	// updatedroot is used to save the changes of the model data.
	updatedroot, err := m.NewRoot(nil)
	if err != nil {
		return
	}
	m.updatedroot = updatedroot
	if m.ChangeNotification != nil {
		m.ChangeNotification.ChangeStarted(m.updatedroot.GetRoot())
	}
}

// UpdateEnd indicates the end of the Model instance update
func (m *Model) UpdateEnd() {
	if m.ChangeNotification != nil {
		m.ChangeNotification.ChangeFinished(m.updatedroot.GetRoot())
	}
	m.updatedroot = nil
	m.Unlock()
}
