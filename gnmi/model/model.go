/* Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
	"fmt"
	"reflect"
	"sort"
	"strings"

	"github.com/neoul/gnxi/gnmi/model/gostruct"
	"github.com/neoul/libydb/go/ydb"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// JSONUnmarshaler is the signature of the Unmarshal() function in the GoStruct code generated by openconfig ygot library.
type JSONUnmarshaler func([]byte, ygot.GoStruct, ...ytypes.UnmarshalOpt) error

// GoStructEnumData is the data type to maintain GoStruct enum type.
type GoStructEnumData map[string]map[int64]ygot.EnumDefinition

// Model contains the model data and GoStruct information for the device.
type Model struct {
	name            string
	modelData       []*gpb.ModelData
	StructRootType  reflect.Type
	SchemaTree      map[string]*yang.Entry
	SchemaTreeRoot  *yang.Entry
	JSONUnmarshaler JSONUnmarshaler
	EnumData        GoStructEnumData
}

// NewModel returns an instance of Model struct.
func NewModel() *Model {
	var name string
	var schemaTreeRoot *yang.Entry
	for key, entry := range gostruct.SchemaTree {
		if entry.Parent == nil {
			name = key
			schemaTreeRoot = entry
			break
		}
	}
	return &Model{
		name:            name,
		modelData:       gostruct.ΓModelData,
		StructRootType:  reflect.TypeOf((*gostruct.Device)(nil)),
		SchemaTree:      gostruct.SchemaTree,
		SchemaTreeRoot:  schemaTreeRoot,
		JSONUnmarshaler: gostruct.Unmarshal,
		EnumData:        gostruct.ΛEnum,
	}
}

// NewCustomModel returns an instance of Model struct.
func NewCustomModel(
	modelData []*gpb.ModelData,
	structRootType reflect.Type,
	schemaTree map[string]*yang.Entry,
	jSONUnmarshaler JSONUnmarshaler,
	enumData GoStructEnumData,
) *Model {
	var name string
	var schemaTreeRoot *yang.Entry
	for key, entry := range schemaTree {
		if entry.Parent == nil {
			name = key
			schemaTreeRoot = entry
			break
		}
	}
	return &Model{
		name:            name,
		modelData:       modelData,
		StructRootType:  structRootType,
		SchemaTree:      schemaTree,
		SchemaTreeRoot:  schemaTreeRoot,
		JSONUnmarshaler: jSONUnmarshaler,
		EnumData:        enumData,
	}
}

// SupportedModels returns a list of supported models.
func (m *Model) SupportedModels() []string {
	mDesc := make([]string, len(m.modelData))
	for i, m := range m.modelData {
		mDesc[i] = fmt.Sprintf("%s %s", m.Name, m.Version)
	}
	sort.Strings(mDesc)
	return mDesc
}

// CheckModels checks whether models are supported by the model. Return error if anything is unsupported.
func (m *Model) CheckModels(models []*gpb.ModelData) error {
	for _, mo := range models {
		isSupported := false
		for _, supportedModel := range m.modelData {
			if reflect.DeepEqual(mo, supportedModel) {
				isSupported = true
				break
			}
		}
		if !isSupported {
			return fmt.Errorf("unsupported model: %v", m)
		}
	}
	return nil
}

// GetModelData - returns ModelData of the model.
func (m *Model) GetModelData() []*gpb.ModelData {
	return m.modelData
}

// FindSchema - find the yang.Entry for schema info.
func (m *Model) FindSchema(t reflect.Type) *yang.Entry {
	if t == reflect.TypeOf(nil) {
		return nil
	}
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
		if t == reflect.TypeOf(nil) {
			return nil
		}
	}
	return m.SchemaTree[t.Name()]
}

// FindSchemaByName - find the yang.Entry for schema info.
func (m *Model) FindSchemaByName(parent *yang.Entry, name string) *yang.Entry {
	return parent.Dir[name]
}

// FindAllPaths - finds all XPaths against to the gNMI Path that has wildcard
func (m *Model) FindAllPaths(path *gpb.Path) ([]string, bool) {
	elems := path.GetElem()
	if len(elems) <= 0 {
		return []string{"/"}, true
	}
	p := ""
	sp := pathFinder{
		t:    m.StructRootType,
		path: &p,
	}

	rsplist := m.findAllPaths(sp, elems)
	num := len(rsplist)
	if num <= 0 {
		return []string{}, false
	}
	rlist := make([]string, num)
	for i := 0; i < num; i++ {
		rlist[i] = *rsplist[i].path
	}
	return rlist, true
}

// findAllPaths - finds all XPaths matched to the gNMI Path.
// It is used to find all schema nodes matched to a wildcard path.
func (m *Model) findAllPaths(sp pathFinder, elems []*gpb.PathElem) []pathFinder {
	// select all child nodes if the current node is a list.
	if sp.t.Kind() == reflect.Map {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}
	if len(elems) <= 0 {
		return []pathFinder{sp}
	}
	if ydb.IsTypeScalar(sp.t) {
		return []pathFinder{}
	}
	elem := elems[0]
	// fmt.Println("** Search", elem.GetName(), "from", sp.t)
	if elem.GetName() == "*" {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, celems)...)
			}
		}
		return rv
	} else if elem.GetName() == "..." {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				ccsplist := m.findAllPaths(csp, celems)
				if len(ccsplist) > 0 {
					rv = append(rv, ccsplist...)
				}
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}

	elemName := elem.GetName()
	csp, ok := findSchemaPath(sp, elemName)
	if !ok {
		return []pathFinder{}
	}
	keys := elem.GetKey()
	if keys != nil && len(keys) > 0 {
		if ydb.IsTypeMap(csp.t) {
			schema := m.FindSchema(csp.t.Elem())
			if schema != nil {
				npath := ""
				knamelist := strings.Split(schema.Key, " ")
				for _, kname := range knamelist {
					kvalue, ok := keys[kname]
					if ok {
						npath = npath + fmt.Sprintf("[%s=%s]", kname, kvalue)
					} else {
						npath = ""
						break
					}
				}
				if npath != "" {
					npath = *csp.path + npath
					csp.path = &npath
				}
			}
		}
	}

	return m.findAllPaths(csp, elems[1:])
}

// FindAllData - finds all data nodes matched to the gNMI Path.
func (m *Model) FindAllData(gs ygot.GoStruct, path *gpb.Path) ([]*DataAndPath, bool) {
	t := reflect.TypeOf(gs)
	entry := m.FindSchema(t)
	if entry == nil {
		return []*DataAndPath{}, false
	}

	elems := path.GetElem()
	if len(elems) <= 0 {
		dataAndGNMIPath := &DataAndPath{
			Value: gs, Path: "/",
		}
		return []*DataAndPath{dataAndGNMIPath}, true
	}
	for _, e := range elems {
		entry = m.FindSchemaByName(entry, e.Name)
		if entry == nil {
			return []*DataAndPath{}, false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return []*DataAndPath{}, false
				}
			}
		}
	}
	v := reflect.ValueOf(gs)
	datapath := &dataAndPath{Value: v, Key: []string{""}}
	founds := findAllData(datapath, elems)
	// fmt.Println(founds)
	num := len(founds)
	if num <= 0 {
		return []*DataAndPath{}, false
	}
	i := 0
	rvalues := make([]*DataAndPath, num)
	for _, each := range founds {
		if each.Value.CanInterface() {
			dataAndGNMIPath := &DataAndPath{
				Value: each.Value.Interface(),
				Path:  strings.Join(each.Key, "/"),
			}
			rvalues[i] = dataAndGNMIPath
			i++
		}
	}
	if i > 0 {
		return rvalues[:i], true
	}
	return []*DataAndPath{}, false
}

// ValidatePathSchema - validates all schema of the gNMI Path.
func (m *Model) ValidatePathSchema(path *gpb.Path) bool {
	t := m.StructRootType
	entry := m.FindSchema(t)
	if entry == nil {
		return false
	}

	elems := path.GetElem()
	if len(elems) <= 0 {
		return true
	}
	for _, e := range elems {
		entry = m.FindSchemaByName(entry, e.Name)
		if entry == nil {
			return false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return false
				}
			}
		}
	}
	return true
}
