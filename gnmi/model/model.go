/* Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package model

import (
	"fmt"
	"reflect"
	"sort"
	"strings"

	"github.com/neoul/gnxi/gnmi/model/gostruct"
	"github.com/neoul/gnxi/utilities/xpath"
	"github.com/neoul/libydb/go/ydb"
	"github.com/neoul/trie"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	gnmipb "github.com/openconfig/gnmi/proto/gnmi"
)

// Model contains the model data and GoStruct information for the device.
type Model struct {
	*ytypes.Schema
	modelData   []*gnmipb.ModelData
	dataroot    ygot.ValidatedGoStruct // the current data tree of the Model
	updatedroot ygot.GoStruct          // a fake data tree to represent the changed data.
	Callback
	block        *ydb.YDB
	syncRequired *trie.Trie
	transaction  *setTransaction
}

// GetName returns the name of the model.
func (m *Model) GetName() string {
	rootSchema := m.RootSchema()
	if rootSchema == nil {
		return "unknown"
	}
	return rootSchema.Name
}

// GetRootType returns the reflect.Type of the root
func (m *Model) GetRootType() reflect.Type {
	return reflect.TypeOf(m.Root).Elem()
}

// NewRoot returns new root (ygot.ValidatedGoStruct)
func (m *Model) NewRoot(jsonData []byte) (ygot.ValidatedGoStruct, error) {
	newRoot := reflect.New(m.GetRootType()).Interface()
	root := newRoot.(ygot.ValidatedGoStruct)
	if jsonData != nil {
		if err := m.Unmarshal(jsonData, root); err != nil {
			return nil, err
		}
		if err := root.Validate(); err != nil {
			return nil, err
		}
	}
	return root, nil
}

// NewModel - returns new model instance based on model/gostruct.
// - startup: The YAML startup data to populate the creating structure (gostruct).
// - cb: Callback interface to be invoked on data change.
func NewModel(startup []byte, cb Callback) (*Model, error) {
	Schema, err := gostruct.Schema()
	if err != nil {
		return nil, status.Error(codes.Internal, err.Error())
	}
	m := &Model{
		Schema:    Schema,
		modelData: gostruct.Î“ModelData,
		Callback:  cb,
	}
	if err := initModel(m, startup); err != nil {
		return nil, err
	}
	return m, nil
}

// NewCustomModel returns new customer model instance.
// - schema func: Schema() func generated by ygot
// - modelData: Supported modues generated by ygot
// - startup: The YAML startup data to populate the creating structure (gostruct).
// - cb: Callback interface to be invoked on data change.
func NewCustomModel(schema func() (*ytypes.Schema, error), modelData []*gnmipb.ModelData, startup []byte, cb Callback) (*Model, error) {
	s, err := schema()
	if err != nil {
		return nil, status.Error(codes.Internal, err.Error())
	}
	m := &Model{
		Schema:    s,
		modelData: modelData,
		Callback:  cb,
	}
	if err := initModel(m, startup); err != nil {
		return nil, err
	}
	return m, nil
}

// initModel - initializes the created model.
func initModel(m *Model, startupYAML []byte) error {
	dataroot, err := m.NewRoot(nil)
	if err != nil {
		return err
	}
	m.dataroot = dataroot
	m.syncRequired = trie.New()

	for _, p := range srpaths {
		// glog.Infof("sync-required-path %s", p)
		entry := m.FindSchemaByXPath(p)
		if entry == nil {
			continue
		}
		sentries := []*yang.Entry{}
		for entry != nil {
			sentries = append([]*yang.Entry{entry}, sentries...)
			entry = entry.Parent
		}
		m.syncRequired.Add(p, sentries)
	}

	m.block, _ = ydb.OpenWithTargetStruct("gnmi.target", m)
	if startupYAML != nil {
		if err := m.block.Parse(startupYAML); err != nil {
			return err
		}
		// [FIXME] - error in creating gnmid: /device/interfaces: /device/interfaces/interface: list interface contains more than max allowed elements: 2 > 0
		// if err := root.Validate(); err != nil {
		// 	//???
		// 	return nil, err
		// }
		// utilities.PrintStruct(dataroot)
	}
	if !*disableYdbChannel {
		err := m.block.Connect("uss://gnmi", "pub")
		if err != nil {
			m.block.Close()
			return err
		}
		m.block.Serve()
	}
	return nil
}

// SupportedModels returns a list of supported models.
func (m *Model) SupportedModels() []string {
	mDesc := make([]string, len(m.modelData))
	for i, m := range m.modelData {
		mDesc[i] = fmt.Sprintf("%s %s", m.Name, m.Version)
	}
	sort.Strings(mDesc)
	return mDesc
}

// CheckModels checks whether models are supported by the model. Return error if anything is unsupported.
func (m *Model) CheckModels(models []*gnmipb.ModelData) error {
	for _, mo := range models {
		isSupported := false
		for _, supportedModel := range m.modelData {
			if reflect.DeepEqual(mo, supportedModel) {
				isSupported = true
				break
			}
		}
		if !isSupported {
			return fmt.Errorf("unsupported model: %v", m)
		}
	}
	return nil
}

// GetModelData - returns ModelData of the model.
func (m *Model) GetModelData() []*gnmipb.ModelData {
	return m.modelData
}

// GetSchema - returns the root yang.Entry of the model.
func (m *Model) GetSchema() *yang.Entry {
	return m.RootSchema()
}

// FindSchemaByType - find the yang.Entry by Type for schema info.
func (m *Model) FindSchemaByType(t reflect.Type) *yang.Entry {
	if t == reflect.TypeOf(nil) {
		return nil
	}
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
		if t == reflect.TypeOf(nil) {
			return nil
		}
	}
	return m.SchemaTree[t.Name()]
}

// FindSchema finds the *yang.Entry by value(ygot.GoStruct) for schema info.
func (m *Model) FindSchema(value interface{}) *yang.Entry {
	return m.FindSchemaByType(reflect.TypeOf(value))
}

// FindSchemaByXPath finds *yang.Entry by XPath string from root model
func (m *Model) FindSchemaByXPath(path string) *yang.Entry {
	return m.FindSchemaByRelativeXPath(m.Root, path)
}

// FindSchemaByRelativeXPath finds *yang.Entry by XPath string from base(ygot.GoStruct)
func (m *Model) FindSchemaByRelativeXPath(base interface{}, path string) *yang.Entry {
	bSchema := m.FindSchema(base)
	if bSchema == nil {
		return nil
	}
	findSchemaByXPath := func(entry *yang.Entry, path string) *yang.Entry {
		slicedPath, err := xpath.ParseStringPath(path)
		if err != nil {
			return nil
		}
		for _, elem := range slicedPath {
			switch v := elem.(type) {
			case string:
				entry = entry.Dir[v]
				if entry == nil {
					return nil
				}
			case map[string]string:
				// skip keys
			default:
				return nil
			}
		}
		return entry
	}
	return findSchemaByXPath(bSchema, path)
}

// FindSchemaByGNMIPath finds the schema(*yang.Entry) using the gNMI Path
func (m *Model) FindSchemaByGNMIPath(path *gnmipb.Path) *yang.Entry {
	return m.FindSchemaByRelativeGNMIPath(m.Root, path)
}

// FindSchemaByRelativeGNMIPath finds the schema(*yang.Entry) using the relative path
func (m *Model) FindSchemaByRelativeGNMIPath(base interface{}, path *gnmipb.Path) *yang.Entry {
	bSchema := m.FindSchema(base)
	if bSchema == nil || path == nil {
		return nil
	}
	findSchema := func(entry *yang.Entry, path *gnmipb.Path) *yang.Entry {
		for _, e := range path.GetElem() {
			entry = entry.Dir[e.GetName()]
			if entry == nil {
				return nil
			}
		}
		return entry
	}
	return findSchema(bSchema, path)
}

// FindAllPaths - finds all XPaths against to the gNMI Path that has wildcard
func (m *Model) FindAllPaths(path *gnmipb.Path) ([]string, bool) {
	elems := path.GetElem()
	if len(elems) <= 0 {
		return []string{"/"}, true
	}
	p := ""
	sp := pathFinder{
		t:    m.GetRootType(),
		path: &p,
	}

	rsplist := m.findAllPaths(sp, elems)
	num := len(rsplist)
	if num <= 0 {
		return []string{}, false
	}
	rlist := make([]string, num)
	for i := 0; i < num; i++ {
		rlist[i] = *rsplist[i].path
	}
	return rlist, true
}

// findAllPaths - finds all XPaths matched to the gNMI Path.
// It is used to find all schema nodes matched to a wildcard path.
func (m *Model) findAllPaths(sp pathFinder, elems []*gnmipb.PathElem) []pathFinder {
	// select all child nodes if the current node is a list.
	if sp.t.Kind() == reflect.Map {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}
	if len(elems) <= 0 {
		return []pathFinder{sp}
	}
	if ydb.IsTypeScalar(sp.t) {
		return []pathFinder{}
	}
	elem := elems[0]
	// fmt.Println("** Search", elem.GetName(), "from", sp.t)
	if elem.GetName() == "*" {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				rv = append(rv, m.findAllPaths(csp, celems)...)
			}
		}
		return rv
	} else if elem.GetName() == "..." {
		rv := []pathFinder{}
		csplist, ok := getAllSchemaPaths(sp)
		if ok {
			celems := elems[1:]
			for _, csp := range csplist {
				ccsplist := m.findAllPaths(csp, celems)
				if len(ccsplist) > 0 {
					rv = append(rv, ccsplist...)
				}
				rv = append(rv, m.findAllPaths(csp, elems)...)
			}
		}
		return rv
	}

	elemName := elem.GetName()
	csp, ok := findSchemaPath(sp, elemName)
	if !ok {
		return []pathFinder{}
	}
	keys := elem.GetKey()
	if keys != nil && len(keys) > 0 {
		if ydb.IsTypeMap(csp.t) {
			schema := m.FindSchemaByType(csp.t.Elem())
			if schema != nil {
				npath := ""
				knamelist := strings.Split(schema.Key, " ")
				for _, kname := range knamelist {
					kvalue, ok := keys[kname]
					if ok {
						npath = npath + fmt.Sprintf("[%s=%s]", kname, kvalue)
					} else {
						npath = ""
						break
					}
				}
				if npath != "" {
					npath = *csp.path + npath
					csp.path = &npath
				}
			}
		}
	}

	return m.findAllPaths(csp, elems[1:])
}

// FindAllData - finds all data nodes matched to the gNMI Path.
func (m *Model) FindAllData(gs ygot.GoStruct, path *gnmipb.Path) ([]*DataAndPath, bool) {
	t := reflect.TypeOf(gs)
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return []*DataAndPath{}, false
	}

	elems := path.GetElem()
	if len(elems) <= 0 {
		dataAndGNMIPath := &DataAndPath{
			Value: gs, Path: "/",
		}
		return []*DataAndPath{dataAndGNMIPath}, true
	}
	for _, e := range elems {
		if e.Name == "*" || e.Name == "..." {
			break
		}
		entry = entry.Dir[e.Name]
		if entry == nil {
			return []*DataAndPath{}, false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return []*DataAndPath{}, false
				}
			}
		}
	}
	v := reflect.ValueOf(gs)
	datapath := &dataAndPath{Value: v, Key: []string{""}}
	founds := findAllData(datapath, elems)
	// fmt.Println(founds)
	num := len(founds)
	if num <= 0 {
		return []*DataAndPath{}, false
	}
	i := 0
	rvalues := make([]*DataAndPath, num)
	for _, each := range founds {
		if each.Value.CanInterface() {
			dataAndGNMIPath := &DataAndPath{
				Value: each.Value.Interface(),
				Path:  strings.Join(each.Key, "/"),
			}
			rvalues[i] = dataAndGNMIPath
			i++
		}
	}
	if i > 0 {
		return rvalues[:i], true
	}
	return []*DataAndPath{}, false
}

// ValidatePathSchema - validates all schema of the gNMI Path.
func (m *Model) ValidatePathSchema(path *gnmipb.Path) bool {
	t := m.GetRootType()
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return false
	}

	elems := path.GetElem()
	if len(elems) <= 0 {
		return true
	}
	for _, e := range elems {
		entry = entry.Dir[e.Name]
		if entry == nil {
			return false
		}
		if e.Key != nil {
			for kname := range e.Key {
				if !strings.Contains(entry.Key, kname) {
					return false
				}
			}
		}
	}
	return true
}

// FindSchemaPaths - validates all schema of the gNMI Path.
func (m *Model) FindSchemaPaths(path *gnmipb.Path) ([]string, bool) {
	t := m.GetRootType()
	entry := m.FindSchemaByType(t)
	if entry == nil {
		return nil, false
	}
	var elems []*gnmipb.PathElem
	elems = path.GetElem()
	if len(elems) == 0 {
		return []string{"/"}, true
	}
	paths := m.findSchemaPath("", entry, elems)
	// for i, p := range paths {
	// 	fmt.Println(i, p)
	// }
	return paths, true
}

func (m *Model) findSchemaPath(prefix string, parent *yang.Entry, elems []*gnmipb.PathElem) []string {
	if len(elems) == 0 {
		return []string{prefix}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]string, 0, 8)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]string, 0, 16)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[1:])...)
			founds = append(founds,
				m.findSchemaPath(prefix+"/"+cname, centry, elems[0:])...)
		}
		return founds
	}
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
	}
	return m.findSchemaPath(prefix+"/"+e.Name, entry, elems[1:])
}

func (m *Model) findDataPath(prefix string, parent *yang.Entry, elems []*gnmipb.PathElem) []string {
	if len(elems) == 0 {
		return []string{prefix}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]string, 0, 8)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]string, 0, 16)
		for cname, centry := range parent.Dir {
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[1:])...)
			founds = append(founds,
				m.findDataPath(prefix+"/"+cname, centry, elems[0:])...)
		}
		return founds
	}
	name := e.Name
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
		knames := strings.Split(entry.Key, " ")
		for _, kname := range knames {
			if kval, ok := e.Key[kname]; ok {
				if kval == "*" {
					break
				}
				name = fmt.Sprintf("%s[%s=%s]", name, kname, kval)
			} else {
				break
			}
		}
	}
	return m.findDataPath(prefix+"/"+name, entry, elems[1:])
}

type dataAndSchemaPath struct {
	schemaPath *string
	dataPath   *string
}

func (m *Model) findSchemaAndDataPath(path dataAndSchemaPath, parent *yang.Entry, elems []*gnmipb.PathElem) []dataAndSchemaPath {
	if len(elems) == 0 {
		return []dataAndSchemaPath{path}
	}
	if parent.Dir == nil || len(parent.Dir) == 0 {
		return nil
	}
	e := elems[0]
	if e.Name == "*" {
		founds := make([]dataAndSchemaPath, 0, 8)
		for cname, centry := range parent.Dir {
			datapath := *path.dataPath + "/" + cname
			schemapath := *path.schemaPath + "/" + cname
			path.dataPath = &datapath
			path.schemaPath = &schemapath
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[1:])...)
		}
		return founds
	} else if e.Name == "..." {
		founds := make([]dataAndSchemaPath, 0, 16)
		for cname, centry := range parent.Dir {
			datapath := *path.dataPath + "/" + cname
			schemapath := *path.schemaPath + "/" + cname
			path.dataPath = &datapath
			path.schemaPath = &schemapath
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[1:])...)
			founds = append(founds,
				m.findSchemaAndDataPath(path, centry, elems[0:])...)
		}
		return founds
	}
	name := e.Name
	entry := parent.Dir[e.Name]
	if entry == nil {
		return nil
	}
	if e.Key != nil {
		for kname := range e.Key {
			if !strings.Contains(entry.Key, kname) {
				return nil
			}
		}
		knames := strings.Split(entry.Key, " ")
		for _, kname := range knames {
			if kval, ok := e.Key[kname]; ok {
				if kval == "*" {
					break
				}
				name = fmt.Sprintf("%s[%s=%s]", name, kname, kval)
			} else {
				break
			}
		}
	}
	datapath := *path.dataPath + "/" + name
	schemapath := *path.schemaPath + "/" + e.Name
	path.dataPath = &datapath
	path.schemaPath = &schemapath
	return m.findSchemaAndDataPath(path, entry, elems[1:])
}
