module hfr-oc-types {

  // namespace
  namespace "urn:hfr:ns:hfr-oc-types";

  // prefix
  prefix "hfr-oc-types";

  import ietf-interfaces { prefix if; }
  import openconfig-extensions { prefix oc-ext; }

  // meta
  organization "HFR,Inc. for Mobile Internet";

  contact 
      "HFR,Inc. for Mobile Internet

      Address: Hana EZ tower 5F, 10, Seongnam-daero 43 beon-gil,
        Bundang-gu, Seongnam-si, Gyeonggi-do, Korea
      Tel: 82-31-712-7768 (Fax: 82-31-712-7948)
      E-mail: resonant@hfrnet.com
      Web: hfrnet.com
      YANG desgined by: neoul@hfrnet.com";

  // Max line length throughout the modules should be 70 cols.

  // Formatting description statements: for consistency, the
  // description text should start on the line following the
  // 'description' keyword and be indented 2 spaces.
  description
    "This module contains basic YANG type definitions for HFR NE 
    model.
    Copyright (c) 2019 HFR,Inc. All rights reserved. ";

  oc-ext:openconfig-version "0.1.1";

  revision "2020-06-01" {
    description
      "Inital model of HFR NE (Network Equipment) YANG model";
    reference "0.1.1";
  }

  identity ROE {
    base if:interface-type;
    description
      "For all Radio over Ethernet interfaces, regardless of speed,
       as per IEEE 1904.3 Radio over Ethernet(RoE).";
  }

  // identity statements
  identity TPID_TYPES {
    description
      "Base identity for TPID values that can override the VLAN
      ethertype value";
  }
  
  identity TPID_0X8100 {
    base TPID_TYPES;
    description
      "Default TPID value for 802.1q single-tagged VLANs.";
  }

  identity TPID_0X88A8 {
    base TPID_TYPES;
    description
      "TPID value for 802.1ad provider bridging, QinQ or
       stacked VLANs.";
  }

  identity TPID_0X9100 {
    base TPID_TYPES;
    description
      "Alternate TPID value";
  }

  identity TPID_0X9200 {
    base TPID_TYPES;
    description
      "Alternate TPID value";
  }

  // typedef statements
  // Thses defined types are referenced from openconfig model.
  typedef dotted-quad {
    type string {
      pattern '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'       +
              '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4]' +
              '[0-9]|25[0-5])$';
    }
    description
      "An unsigned 32-bit integer expressed as a dotted quad. The
      format is four octets written as decimal numbers separated
      with a period character.";
  }

  typedef hex-string {
    type string {
      pattern '^[0-9a-fA-F]*$';
    }
    description
      "A string consisting of a hexadecimal characters.";
  }

  typedef counter32 {
    type uint32;
    description

      "A 32-bit counter. A counter value is a monotonically increasing
      value which is used to express a count of a number of
      occurrences of a particular event or entity. When the counter
      reaches its maximum value, in this case 2^32-1, it wraps to 0.

      Discontinuities in the counter are generally triggered only when
      the counter is reset to zero.";
  }

  typedef counter64 {
    type uint64;
    description

      "A 64-bit counter. A counter value is a monotonically increasing
      value which is used to express a count of a number of
      occurrences of a particular event or entity. When a counter64
      reaches its maximum value, 2^64-1, it loops to zero.
      Discontinuities in a counter are generally triggered only when
      the counter is reset to zero, through operator or system
      intervention.";
  }

  typedef date-and-time {
    type string {
      pattern
        '^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}' +
        '(\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$';
    }
    description
      "A date and time, expressed in the format described in RFC3339.
      That is to say:

      YYYY-MM-DDTHH:MM:SSZ+-hh:mm

      where YYYY is the year, MM is the month expressed as a two-digit
      month (zero padding if required), DD is the day of the month,
      expressed as a two digit value. T is the literal character 'T',
      HH is the hour of the day expressed as a two digit number, using
      the 24-hour clock, MM is the minute of the hour expressed as a
      two digit number. Z is the literal character 'Z', followed by a
      timezone offset expressed in hours (hh) and minutes (mm), both
      expressed as two digit numbers. The time offset is specified as
      a positive or negative offset to UTC using the '+' or '-'
      character preceding the offset.

      Optionally, fractional seconds can be expressed after the minute
      of the hour as a decimal number of unspecified precision
      reflecting fractions of a second.";
    reference
      "RFC3339 - Date and Time on the Internet: Timestamps";
  }

  typedef date-and-time-no-timezone {
    type string {
      pattern
        '^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}' +
        '(\.[0-9]+)?$';
    }
    description
      "A date and time, expressed in the format described in RFC3339.
      That is to say:

      YYYY-MM-DDTHH:MM:SS

      where YYYY is the year, MM is the month expressed as a two-digit
      month (zero padding if required), DD is the day of the month,
      expressed as a two digit value. T is the literal character 'T',
      HH is the hour of the day expressed as a two digit number, using
      the 24-hour clock, MM is the minute of the hour expressed as a
      two digit number.

      Optionally, fractional seconds can be expressed after the minute
      of the hour as a decimal number of unspecified precision
      reflecting fractions of a second.";
    reference
      "RFC3339 - Date and Time on the Internet: Timestamps";
  }

  typedef date {
    type string {
      pattern '^[0-9]{4}\-[0-9]{2}\-[0-9]{2}$';
    }
    description
      "A full UTC date, expressed in the format described in RFC3339.
      That is to say:

      YYYY-MM-DD

      where YYYY is the year, MM is the month expressed as a two-digit
      month (zero padding if required), DD is the day of the month,
      expressed as a two digit value.";

    reference
      "RFC3339 - Date and Time on the Internet: full-date";
  }

  typedef gauge64 {
    type uint64;
    description
      "A gauge value may increase or decrease - and reflects a value
      at a particular point in time. If the value of the variable
      being modeled using the gauge exceeds its maximum - 2^64-1 in
      this case - the gauge is set to its maximum value.";
  }

  typedef phys-address {
    type string {
      pattern '^([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?$';
    }
    description
      "A physical layer address, expressed as a series of pairs of
      hexadecimal digits.";
  }

  typedef mac-address {
    type string {
      pattern '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$';
    }
    description
      "An IEEE 802 MAC address";
  }

  typedef vlan-id {
    type uint16 {
      range 1..4094;
    }
    description
      "Type definition representing a VLAN ID";
  }
  
  typedef vlan-priority {
    type uint8 {
      range 0..7;
    }
    description
      "Type definition representing the priority of a VLAN";
  }

  typedef vlan-range {
    type string {
      pattern '[0-9]{1,4}([,-][0-9]{1,4})*';
    }
    description
      "Type definition representing the a number of ranges of
      single-tagged VLANs. (e.g. '1-200,300') Each VLAN-ID or VLAN range
      in the vlan-range type is specified as x-y,z where x, y and z are
      valid VLAN IDs (1 <= vlan-id <= 4094). The VLAN range is assumed 
      to be inclusive, such that any VLAN-ID matching x <= VLAN-ID <= y 
      falls within the range.";
  }

  typedef qinq-id {
    type string {
      pattern
        '^(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'      +
        '[1-9][0-9]{1,2}|[1-9])\.'                    +
        '((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'      +
        '[1-9][0-9]{1,2}|[1-9])|\*)$';
    }
    description
      "Type definition representing a single double-tagged/QinQ VLAN
      identifier. The format of a QinQ VLAN-ID is x.y where X is the
      'outer' VLAN identifier, and y is the 'inner' VLAN identifier.
      Both x and y must be valid VLAN IDs (1 <= vlan-id <= 4094)
      with the exception that y may be equal to a wildcard (*). In
      cases where y is set to the wildcard, this represents all inner
      VLAN identifiers where the outer VLAN identifier is equal to
      x";
  }

  typedef qinq-id-range {
    type union {
      type string {
        // match cases where the range is specified as x..y.z
        pattern
          '^(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'    +
          '[1-9][0-9]{1,2}|[1-9])\.\.'               +
          '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'    +
          '[1-9][0-9]{1,2}|[1-9])\.'                 +
          '((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'   +
          '[1-9][0-9]{1,2}|[1-9])|\*)$';
      }
      type string {
        // match cases where the range is specified as x.y..z
        pattern
          '^(\*|(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'    +
          '[1-9][0-9]{1,2}|[1-9]))\.'                 +
          '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'    +
          '[1-9][0-9]{1,2}|[1-9])\.\.'               +
          '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|'    +
          '[1-9][0-9]{1,2}|[1-9])$';
      }
    }
    description
      "A type definition representing a range of double-tagged/QinQ
      VLAN identifiers. The format of a QinQ VLAN-ID range can be
      specified in three formats. Where the range is outer VLAN IDs
      the range is specified as x..y.z. In this case outer VLAN
      identifiers meeting the criteria x <= outer-vlan-id <= y are
      accepted iff the inner VLAN-ID is equal to y - or any inner-tag
      if the wildcard is specified. Alternatively the range can be
      specified as x.y..z. In this case only VLANs with an
      outer-vlan-id qual to x are accepted (x may again be the
      wildcard). Inner VLANs are accepted if they meet the inequality
      y <= inner-vlan-id <= z.";
  }

  typedef vlan-mode-type {
    type enumeration {
      enum ACCESS {
        description "Access mode VLAN interface (No 802.1q header)";
      }
      enum TRUNK {
        description "Trunk mode VLAN interface";
      }
    }
    description
      "VLAN interface mode (trunk or access)";
  }

  typedef queue-id {
    type uint8 {
      range 0..7;
    }
    description
      "Type definition representing a QUEUE-ID";
  }

  typedef queue-range {
    type string {
      pattern '[0-7]{1}([,][0-7]{1}){,7}';
    }
    description
      "Type definition representing a QUEUE-ID";
  }

  typedef percentage {
    type uint8 {
      range "0..100";
    }
    description
      "Integer indicating a percentage value";
  }

  // typedef timeticks64 {
  //   type uint64;
  //   description
  //    "This type is based on the timeticks type defined in
  //    RFC 6991, but with 64-bit width.  It represents the time,
  //    modulo 2^64, in hundredths of a second between two epochs.";
  //   reference
  //     "RFC 6991 - Common YANG Data Types";
  // }

  // typedef stat-interval {
  //   type uint64;
  //   units nanoseconds;
  //   description
  //     "A time interval over which a set of statistics is computed.
  //     A common usage is to report the interval over which
  //     avg/min/max stats are computed and reported.";
  // }

  // grouping stat-interval-state {
  //   description
  //     "Reusable leaf definition for stats computation interval";

  //   leaf interval {
  //     type stat-interval;
  //     description
  //       "If supported by the system, this reports the time interval
  //       over which the min/max/average statistics are computed by
  //       the system.";
  //   }
  // }

  // grouping min-max-time {
  //   description
  //     "Common grouping for recording the absolute time at which
  //     the minimum and maximum values occurred in the statistics";

  //   leaf min-time {
  //     type timeticks64;
  //     description
  //       "The absolute time at which the minimum value occurred.
  //        The value is the timestamp in nanoseconds relative to
  //         the Unix Epoch (Jan 1, 1970 00:00:00 UTC).";
  //   }

  //   leaf max-time {
  //     type timeticks64;
  //     description
  //       "The absolute time at which the maximum value occurred.
  //        The value is the timestamp in nanoseconds relative to
  //         the Unix Epoch (Jan 1, 1970 00:00:00 UTC).";
  //   }
  // }

  // grouping avg-min-max-stats-precision1 {
  //   description
  //     "Common nodes for recording average, minimum, and
  //     maximum values for a statistic.  These values all have
  //     fraction-digits set to 1.  Statistics are computed
  //     and reported based on a moving time interval (e.g., the last
  //     30s).  If supported by the device, the time interval over which
  //     the statistics are computed is also reported.";

  //   leaf avg {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     description
  //       "The arithmetic mean value of the statistic over the
  //       time interval.";
  //   }

  //   leaf min {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     description
  //       "The minimum value of the statistic over the time
  //       interval.";
  //   }

  //   leaf max {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     description
  //       "The maximum value of the statitic over the time
  //       interval.";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }

  // grouping avg-min-max-instant-stats-precision1 {
  //   description
  //     "Common grouping for recording an instantaneous statistic value
  //     in addition to avg-min-max stats";

  //   leaf instant {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     description
  //       "The instantaneous value of the statistic.";
  //   }

  //   uses avg-min-max-stats-precision1;
  // }

  // grouping avg-min-max-instant-stats-precision2-dB {
  //   description
  //     "Common grouping for recording dB values with 2 decimal
  //     precision. Values include the instantaneous, average,
  //     minimum, and maximum statistics.  Statistics are computed
  //     and reported based on a moving time interval (e.g., the last
  //     30s).  If supported by the device, the time interval over which
  //     the statistics are computed, and the times at which the minimum
  //     and maximum values occurred, are also reported.";

  //   leaf instant {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dB;
  //     description
  //       "The instantaneous value of the statistic.";
  //   }

  //   leaf avg {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dB;
  //     description
  //       "The arithmetic mean value of the statistic over the
  //       time interval.";
  //   }

  //   leaf min {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dB;
  //     description
  //       "The minimum value of the statistic over the time interval.";
  //   }

  //   leaf max {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dB;
  //     description
  //       "The maximum value of the statistic over the time
  //       interval.";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }

  // grouping avg-min-max-instant-stats-precision2-dBm {
  //   description
  //     "Common grouping for recording dBm values with 2 decimal
  //     precision. Values include the instantaneous, average,
  //     minimum, and maximum statistics.  Statistics are computed
  //     and reported based on a moving time interval (e.g., the last
  //     30s).  If supported by the device, the time interval over which
  //     the statistics are computed, and the times at which the minimum
  //     and maximum values occurred, are also reported.";

  //   leaf instant {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dBm;
  //     description
  //       "The instantaneous value of the statistic.";
  //   }

  //   leaf avg {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dBm;
  //     description
  //       "The arithmetic mean value of the statistic over the
  //       time interval.";
  //   }

  //   leaf min {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dBm;
  //     description
  //       "The minimum value of the statistic over the time
  //       interval.";
  //   }

  //   leaf max {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units dBm;
  //     description
  //       "The maximum value of the statistic over the time interval.";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }

  // grouping avg-min-max-instant-stats-precision2-mA {
  //   description
  //     "Common grouping for recording mA values with 2 decimal
  //     precision. Values include the instantaneous, average,
  //     minimum, and maximum statistics.  Statistics are computed
  //     and reported based on a moving time interval (e.g., the last
  //     30s).  If supported by the device, the time interval over which
  //     the statistics are computed, and the times at which the minimum
  //     and maximum values occurred, are also reported.";

  //   leaf instant {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units mA;
  //     description
  //       "The instantaneous value of the statistic.";
  //   }

  //   leaf avg {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units mA;
  //     description
  //       "The arithmetic mean value of the statistic over the
  //       time interval.";
  //   }

  //   leaf min {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units mA;
  //     description
  //       "The minimum value of the statistic over the time
  //       interval.";
  //   }

  //   leaf max {
  //     type decimal64 {
  //       fraction-digits 2;
  //     }
  //     units mA;
  //     description
  //       "The maximum value of the statistic over the time
  //       interval.";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }

  // grouping avg-min-max-instant-stats-pct {
  //   description
  //     "Common grouping for percentage statistics.
  //     Values include the instantaneous, average,
  //     minimum, and maximum statistics.  Statistics are computed
  //     and reported based on a moving time interval (e.g., the last
  //     30s).  If supported by the device, the time interval over which
  //     the statistics are computed, and the times at which the minimum
  //     and maximum values occurred, are also reported.";

  //   leaf instant {
  //     type percentage;
  //     description
  //       "The instantaneous percentage value.";
  //   }

  //   leaf avg {
  //     type percentage;
  //     description
  //       "The arithmetic mean value of the percentage measure of the
  //       statistic over the time interval.";
  //   }

  //   leaf min {
  //     type percentage;
  //     description
  //       "The minimum value of the percentage measure of the
  //       statistic over the time interval.";
  //   }

  //   leaf max {
  //     type percentage;
  //     description
  //       "The maximum value of the percentage measure of the
  //       statistic over the time interval.";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }

  // grouping avg-min-max-instant-stats-precision1-celsius {
  //   description
  //     "Common grouping for recording temperature values in
  //     Celsius with 1 decimal precision. Values include the
  //     instantaneous, average, minimum, and maximum statistics";

  //   leaf instant {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     units celsius;
  //     description
  //       "The instantaneous value of the statistic.";
  //   }

  //   leaf avg {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     units celsius;
  //     description
  //       "The arithmetic mean value of the statistic over the
  //       sampling period.";
  //   }

  //   leaf min {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     units celsius;
  //     description
  //       "The minimum value of the statistic over the sampling
  //       period";
  //   }

  //   leaf max {
  //     type decimal64 {
  //       fraction-digits 1;
  //     }
  //     units celsius;
  //     description
  //       "The maximum value of the statistic over the sampling
  //       period";
  //   }

  //   uses stat-interval-state;
  //   uses min-max-time;
  // }
}
